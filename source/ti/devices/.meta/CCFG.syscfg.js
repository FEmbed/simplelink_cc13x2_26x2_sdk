/*
 * Copyright (c) 2019-2020 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== CCFG.syscfg.js ========
 */

const Common = system.getScript("/ti/drivers/Common.js");

const numPins = 48;
const device = system.deviceData.deviceId;
const isBAW = device.match(/CC2652RB/) !== null;
const isSIP = device.match(/CC2652.*SIP/) !== null;

const templateModule = [{
    name: "ccfgTemplate",
    moduleName: "/ti/devices/CCFGTemplate"
}];

const templateInitModule =[{
    name: "ccfgTemplate",
    moduleName: "/ti/devices/CCFGTemplateInit"
}];

let templateModuleInstance = templateModule;

const moduleDesc = `
The [__CCFG area__][1] is the last flash memory sector that must contain a
Customer Configuration section (CCFG) that is used by boot ROM and TI provided
drivers to configure the device. This configuration is done through the ccfg.c
source file that is included in all TI provided examples. The file generated by
this tool can be used to overwrite the default configuration, this is done by
simply including the generated file.

* [Detailed Field Description][2]
* [API access][3]

[1]: /driverlib_cc13xx_cc26xx/cc13x2_cc26x2/driverlib/index.html#ccfg "Basic usage summary"
[2]: /driverlib_cc13xx_cc26xx/cc13x2_cc26x2/register_descriptions/CPU_MMAP/CCFG.html "CCFG field description"
[3]: /driverlib_cc13xx_cc26xx/cc13x2_cc26x2/driverlib/group__ccfgread__api.html "CCFG access API"`;

const config = [
    // Power settings
    {
        name: "forceVddr",
        displayName: "Force VDDR",
        description: "Necessary for external load mode, or for maximum PA output power",
        default: false,
        readOnly: false,
        hidden: false
    },
    {
        name: "enableDCDC",
        displayName: "Enable DCDC",
        description: "Enable or disable use of DCDC.",
        readOnly: false,
        hidden: false,
        default: true
    },
    // Clock settings
    {
        name: "srcClkLF",
        displayName: "LF Clock Source",
        description: "Low frequency clock source",
        readOnly: false,
        hidden: false,
        options: [
            {name: "Derived from HF XOSC"},
            {name: "External LF clock"},
            {name: "LF XOSC"},
            {name: "LF RCOSC"}
        ],
        default: "LF XOSC",
        onChange: (inst, ui) => {
            ui.extClkDio.hidden = !(inst.srcClkLF === "External LF clock");
            ui.rtcIncrement.hidden = !(inst.srcClkLF === "External LF clock");
        }
    },
    {
        name: "extClkDio",
        displayName: "External LF Clock DIO",
        description: "DIO number if using external LF clock",
        readOnly: false,
        hidden: true,
        displayFormat: {radix: "dec", fixedPoint: 0},
        default: 1
    },
    {
        name: "rtcIncrement",
        displayName: "RTC Increment",
        description: "RTC increment for the external LF clock frequency",
        readOnly: false,
        hidden: true,
        displayFormat: "hex",
        default: 0x800000
    },
    {
        name: "xoscCapArray",
        displayName: "XOSC Cap Array Modification",
        description: "Enables modification (delta) to XOSC cap-array",
        default: false,
        readOnly: false,
        hidden: false,
        onChange: (inst, ui) => {
            if (inst.xoscCapArray === true) {
                ui.xoscCapArrayDelta.hidden = false;
            }
            else {
                ui.xoscCapArrayDelta.hidden = true;
            }
        }
    },
    {
        name: "xoscCapArrayDelta",
        displayName: "XOSC Cap Array Delta",
        description: "Modify the high frequency oscillator cap-array, changing the frequency offset",
        longDescription: "The cap-array delta value is an offset from the default value of the load"
            + " capacitor on the high frequency oscillator.\n\n"
            + " More information can be found in the application report [CC13xx/CC26xx Hardware"
            + " Configuration and PCB Design Considerations]"
            + "(http://www.ti.com/general/docs/lit/getliterature.tsp?baseLiteratureNumber=swra640)",
        displayFormat: {radix: "hex", bitSize: 2},
        default: 0xFF,
        readOnly: false,
        hidden: true
    },
    // Special HF clock source setting
    {
        name: "srcClkHF",
        displayName: "HF Clock Source",
        description: "High Frequency Clock Source",
        readOnly: isBAW,
        hidden: false,
        options: isBAW
            ? [
                {name: "Internal High Precision Oscillator"}
            ] : [
                {name: "48 MHz XOSC_HF"},
                {name: "External 48Mhz TCXO"}
            ],
        default: isBAW ? "Internal High Precision Oscillator" : "48 MHz XOSC_HF",
        onChange: (inst, ui) => {
            if (inst.srcClkHF === "External 48Mhz TCXO") {
                ui.tcxoType.hidden = false;
                ui.tcxoMaxStartup.hidden = false;
            }
            else {
                ui.tcxoType.hidden = true;
                ui.tcxoMaxStartup.hidden = true;
            }
        }
    },
    {
        name: "tcxoType",
        displayName: "TCXO Type",
        description: "Sets the TCXO Type",
        longDescription: "Sets the Temperature Compensated Crystal Oscillator type\n\n"
            + "* _CMOS type:_ Internal common-mode bias will not be enabled\n"
            + "* _Clipped-sine type:_ Internal common-mode bias will be enabled when TCXO is used.",
        readOnly: false,
        hidden: true,
        options: [
            {name: "CMOS Type"},
            {name: "Clipped-sine Type"}
        ],
        default: "CMOS Type"
    },
    {
        name: "tcxoMaxStartup",
        displayName: "TCXO Max Startup Time",
        description: "Maximum Temperature Compensated Crystal Oscillator startup time in units of 100us",
        displayFormat: {radix: "hex", bitSize: 2},
        readOnly: false,
        hidden: true,
        default: 0x7F
    },
    // RF temperature compensation
    {
        name: "enableXoscHfComp",
        displayName: "RF Temperature Compensation",
        description: "Compensate XOSC_HF frequency for temperature during radio transmissions.",
        longDescription: "Compensate XOSC_HF frequency for temperature during radio transmissions. This improves the accuracy of the XOSC_HF over temperature. This should only be enabled if the selected XOSC_HF source is not accurate enough for a selected stack. It is primarily needed when using HPOSC or when the IO Link Wireless stack with a regular 48 MHz crystal that does not fullfil the PPM requirements of the IOLW stack over the entire temperature range.",
        readOnly: isBAW,
        hidden: false,
        default: isBAW ? true : false,
        onChange: (inst, ui) => {
            ui.useFcfgXoscHfInsertion.hidden = (inst.enableXoscHfComp === false) || isBAW || !isSIP;
            ui.xoscSinglePointCalibration.hidden = (inst.useFcfgXoscHfInsertion === true) || (inst.enableXoscHfComp === false) || isBAW;
        }
    },
    {
        name: "useFcfgXoscHfInsertion",
        displayName: "Use FCFG XOSC_HF Calibration",
        description: "Use XOSC_HF single point temperature calibration measurement stored in FCFG.",
        longDescription: "Some devices, such as the SIP modules, have an XOSC_HF single point temperature calibration measurement programmed into FCFG. It is recommended to use this setting if it is available. It may be deselected to provide application-specified calibration measurements for debug purposes.",
        readOnly: false,
        hidden: true,
        default: isSIP,
        onChange: (inst, ui) => {
            ui.xoscSinglePointCalibration.hidden = (inst.useFcfgXoscHfInsertion === true);
        }
    },
    {
        name: "xoscSinglePointCalibration",
        displayName: "XOSC Single Point Calibration",
        description: "XOSC_HF single point temperature calibration measurement used to characterize the XOSC_HF.",
        readOnly: false,
        hidden: true,
        default: ""
    },
    // Bootloader
    {
        name: "enableBootloader",
        displayName: "Enable Bootloader",
        description: "Enable ROM Bootloader, for flashing from external host",
        default: false,
        onChange: (inst, ui) => {
            if (inst.enableBootloader === true) {
                ui.enableBootloaderBackdoor.hidden = false;
                if (inst.enableBootloaderBackdoor === true) {
                    ui.dioBootloaderBackdoor.hidden = false;
                    ui.levelBootloaderBackdoor.hidden = false;
                }
            }
            else {
                ui.enableBootloaderBackdoor.hidden = true;
                ui.dioBootloaderBackdoor.hidden = true;
                ui.levelBootloaderBackdoor.hidden = true;
            }
        }
    },
    {
        name: "enableBootloaderBackdoor",
        displayName: "Enable Bootloader Backdoor",
        description: "Enables bootloader backdoor",
        longDescription: "When enabling the Bootloader Backdoor, the "
            + "Bootloader can be activated externally by pulling a pin, "
            + "even when a valid flash image is present. "
            + "Note, enabling the backdoor allows an external host to "
            + "read back a flash image from the device",
        readOnly: false,
        hidden: true,
        default: false,
        onChange: (inst, ui) => {
            if (inst.enableBootloaderBackdoor === true) {
                ui.dioBootloaderBackdoor.hidden = false;
                ui.levelBootloaderBackdoor.hidden = false;
            }
            else {
                ui.dioBootloaderBackdoor.hidden = true;
                ui.levelBootloaderBackdoor.hidden = true;
            }
        }
    },
    {
        name: "dioBootloaderBackdoor",
        displayName: "Bootloader Backdoor DIO",
        description: "DIO (pin) to trigger Bootloader backdoor, "
            + "this pin is only needed at boot",
        readOnly: false,
        hidden: true,
        displayFormat: {radix: "dec", fixedPoint: 0},
        default: 32
    },
    {
        name: "levelBootloaderBackdoor",
        displayName: "Trigger Level of Bootloader Backdoor",
        description: "Active high or low on selected DIO to open "
            + "boot loader backdoor",
        readOnly: false,
        hidden: true,
        options: [
            {name: "Active high"},
            {name: "Active low"}
        ],
        default: "Active high"
    },
    // Alternative IEEE 802.15.4 MAC address
    {
        name: "configureIEEE",
        displayName: "Configure IEEE MAC Address",
        description: "Configure alternative IEEE 802.15.4 MAC address",
        readOnly: false,
        hidden: false,
        default: false,
        onChange: (inst, ui) => {
            ui.addressIEEE.hidden = (inst.configureIEEE === false);
        }
    },
    {
        name: "addressIEEE",
        displayName: "IEEE MAC Address",
        description: "Alternative IEEE 802.15.4 MAC address",
        textType: "mac_address_64",
        readOnly: false,
        hidden: true,
        default: "ff:ff:ff:ff:ff:ff:ff:ff"
    },
    // Alternative BLE address
    {
        name: "configureBLE",
        displayName: "Configure BLE Address",
        description: "Configure alternative Bluetooth Low Energy MAC address",
        readOnly: false,
        hidden: false,
        default: false,
        onChange: (inst, ui) => {
            ui.addressBLE.hidden = (inst.configureBLE === false);
        }
    },
    {
        name: "addressBLE",
        displayName: "BLE Address",
        description: "Alternative BLE address",
        textType: "mac_address_64",
        readOnly: false,
        hidden: true,
        default: "ff:ff:ff:ff:ff:ff:ff:ff"
    },
    // Select between cache or GPRAM
    {
        name: "disableCache",
        displayName: "Disable Flash Cache",
        description: "Disable Flash Cache, making GPRAM available "
            + "for alternative use",
        readOnly: false,
        hidden: false,
        default: false
    },
    // Debug access
    {
        displayName: "Debug Access",
        description: "Debug access options",
        config: [
            {
                name: "FailureAnalysis",
                displayName: "TI Failure Analysis",
                description: "TI Failure Analysis",
                longDescription: "If enabled, it is possible for TI to unlock access to the "
                    + "DAP and all TAPs on the device with a security key to perform failure analysis",
                readOnly: false,
                hidden: false,
                default: false
            },
            {
                name: "CpuDap",
                displayName: "CPU DAP",
                description: "CPU Debug Access Port, used for memory access during debugging",
                readOnly: false,
                hidden: false,
                default: true
            },
            {
                name: "PwrprofTap",
                displayName: "PWRPROF TAP",
                description: "PWRPROF Test Access Port, used for power profiling, "
                    + "measuring of current consumption and more",
                readOnly: false,
                hidden: false,
                default: true
            },
            {
                name: "TestTap",
                displayName: "TEST TAP",
                description: "TEST TAP, For TI internal use",
                readOnly: false,
                hidden: false,
                default: false
            },
            {
                name: "Pbist2Tap",
                displayName: "PBIST2 TAP",
                description: "PBIST2 TAP, For TI internal use",
                readOnly: false,
                hidden: false,
                default: false
            },
            {
                name: "Pbist1Tap",
                displayName: "PBIST1 TAP",
                description: "PBIST1 TAP, For TI internal use",
                readOnly: false,
                hidden: false,
                default: false
            },
            {
                name: "AonTap",
                displayName: "AON TAP",
                description: "Always On Test Access Port, used for flash and chip erase",
                readOnly: false,
                hidden: false,
                default: false
            }
        ]
    },
    {
        name: "enableCodeGeneration",
        description: "Enables or disables generation of ti_devices_config.c.",
        longDescription: `This configurable may be used to enable or disable
generation of the ti_devices_config.c file. To support early initialization
on some devices, this module will continue to generate functions to
__Board_init()__ inside the ti_drivers_config.c file. Additionally, any
necessary headers will be generated inside the ti_drivers_config.h file.
`,
        hidden: true,
        default: true,
        onChange: (inst, ui) => {
                templateModuleInstance = inst.enableCodeGeneration ? templateModule : templateInitModule;
        }
    }
];

/*!
 *  ======== validate ========
 *  Validate this module's configuration
 *
 *  @param inst       - RF Settings instance to be validated
 *  @param validation - Issue reporting object
 */
function validate(inst, validation) {
    const MIN_DIO = 1;
    const MAX_DIO = numPins;

    // Check that the single point insertion value exists
    if (inst.enableXoscHfComp === true &&
        inst.useFcfgXoscHfInsertion === false &&
        !isBAW &&
        inst.xoscSinglePointCalibration === "") {
        Common.logError(validation, inst, "xoscSinglePointCalibration",
            "No XOSC_HF calibration temperature measurement provided!");
        return;
    }

    // DIO check Ext Clk DIO
    if (inst.extClkDio < MIN_DIO || inst.extClkDio > MAX_DIO) {
        Common.logError(validation, inst, "extClkDio",
            "Valid range for integer: " + MIN_DIO + " to " + MAX_DIO);
        return;
    }

    // DIO check backdoor
    if (inst.dioBootloaderBackdoor < MIN_DIO
        || inst.dioBootloaderBackdoor > MAX_DIO) {
        Common.logError(validation, inst, "dioBootloaderBackdoor",
            "Valid range for integer: " + MIN_DIO + " to " + MAX_DIO);
        return;
    }

    // RTC increment check
    if (inst.rtcIncrement < 0 || inst.rtcIncrement > 0xffffffff) {
        Common.logError(validation, inst, "rtcIncrement",
            "Valid range: 0 to 0xffffffff");
    }

    // XOSC Cap array delta
    if (inst.xoscCapArrayDelta < 0 || inst.xoscCapArrayDelta > 0xFF) {
        Common.logError(validation, inst, "xoscCapArrayDelta",
            "Valid range: 0 to 0xFF");
    }

    // TCXO Max Startup
    if (inst.tcxoMaxStartup < 0 || inst.tcxoMaxStartup > 0xFF) {
        Common.logError(validation, inst, "tcxoMaxStartup",
            "Valid range: 0 to 0xFF");
    }
}

/*
 *  ======== modules ========
 */
function modules(inst) {
    let tmpModules = [];

    // If SCLK_LF derived from HPOSC, tell the power driver it needs to
    // include the Temperature driver and setup the RTC compensation
    if ((inst.srcClkHF === "Internal High Precision Oscillator") &&
        (inst.srcClkLF === "Derived from HF XOSC")) {

        tmpModules.push({
                            name: "Temperature",
                            moduleName: "/ti/drivers/Temperature"
                         });
    }

    return tmpModules;
}

const CCFGModule = {
    displayName: "Device Configuration",
    description: "Customer Configuration",
    alwaysShowLongDescription : true,
    longDescription: moduleDesc,
    maxInstances: 1,
    moduleStatic: {
        modules: modules,
        config: config,
        validate: validate,
        moduleInstances: () => { return templateModuleInstance; }
    }
};


exports = CCFGModule;
