%%{
/*
 * Copyright (c) 2019-2020 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *  ======== ERPC.cpp.xdt ========
 */
%%}
%%{
    let ERPC = system.modules["/ti/rpc/ERPC"];
    let Interface = system.modules["/ti/rpc/Interface"];

    /*
     *  ======== findInterfaces ========
     *  Find Interface instances owned by the given ERPC instance
     *
     *  Interface instances are created two ways, interactively using
     *  the instance adder or using instance requirements. These instances
     *  are attached to the parent using different properties. This finds
     *  the instances and returns them in an array.
     */
    function findInterfaces(inst)
    {
        let ifs = new Array();

        /* find interfaces on the given instance */
        if (("interfaces" in inst) && inst.interfaces.length) {
            for (let i = 0; i < inst.interfaces.length; i++) {
                ifs.push(inst.interfaces[i]);
            }
        }
        else {
            for (const p in inst) {
                if (p.match(/^interface_\d+$/)) {
                    ifs.push(inst[p]);
                }
            }
        }

        /* look for interfaces on parent nodes */
        function findParentInterfaces(inst)
        {
            let ifs = new Array();

            for (let i = 0; i < Interface.$instances.length; i++) {
                if (Interface.$instances[i].$ownedBy == inst) {
                    ifs.push(Interface.$instances[i]);
                }
            }

            return (ifs);
        }

        if (inst.$ownedBy) {
            ifs = ifs.concat(findParentInterfaces(inst.$ownedBy));
        }
        else if (inst.$sharedBy) {
            for (let j = 0; j < inst.$sharedBy.length; j++) {
                let p = inst.$sharedBy[j];
                ifs = ifs.concat(findParentInterfaces(p));
            }
        }

        return (ifs);
    }

    /* scan instances and track which transports are used */
    let msgque_used = false;
    let sluart_used = false;

    for (let i = 0; i < ERPC.$instances.length; i++) {
        if (ERPC.$instances[i].transport == "pcl") msgque_used = true;
        if (ERPC.$instances[i].transport == "uart") sluart_used = true;
    }
%%}
/*
 *  ======== ti_rpc_erpc.cpp ========
 *  EmbeddedRPC run-time setup
 *
 *  DO NOT EDIT - This file is generated by the SysConfig tool.
 */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>

#include <erpc_client_setup.h>
#include <erpc_mbf_setup.h>
#include <erpc_server_setup.h>
#include <erpc_transport_setup.h>
#include <erpc_arbitrated_client_setup.h>
#include <erpc_manually_constructed.h>
#include <erpc_client_manager.h>
#include <erpc_arbitrated_client_manager.h>
#include <erpc_transport_arbitrator.h>
#include <erpc_simple_server.h>
#include <erpc_basic_codec.h>
#include <erpc_crc16.h>
%
% if (msgque_used) {

#include <erpc_msgque_transport.h>
#include <erpc_setup_mbf_msgque.h>
#include <ti/pcl/MsgQue.h>
#include "ti_pcl_config.h"
% }
%
% if (sluart_used) {

#include <erpc_uart_simplelink_transport.h>
#include <ti/drivers/UART.h>
#include "ti_drivers_config.h"
% }

% for (let i = 0; i < ERPC.$instances.length; i++) {
% let inst = ERPC.$instances[i];
% let ifs = findInterfaces(inst);
% if (inst.role == "client") {
% // Servers without groups will share the same source file. Track the
% // common header names in order to eliminate duplicates.
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (inst.hasCbk && ifs[j].isCbk) {
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_server";
% if (used.indexOf(name) == -1) {
% let ns = (inst.namespace != "" ? inst.namespace + "/" : "");
#include <`ns``name`.h>
% used += name + "/";
% }
% }
% }
% } else { // role: server
% // Servers without groups will share the same source file. Track the
% // common header names in order to eliminate duplicates.
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_server";
% if (used.indexOf(name) == -1) {
% let ns = (inst.namespace != "" ? inst.namespace + "/" : "");
#include <`ns``name`.h>
% used += name + "/";
% }
% }
% }
% }

using namespace erpc;
%
% for (let i = 0; i < ERPC.$instances.length; i++) {
% let inst = ERPC.$instances[i];
% let ifs = findInterfaces(inst);
% if (inst.role == "client") {

/* IDL: `inst.idl`, client manager objects */
% if (msgque_used) {
static ManuallyConstructed<MsgQueTransport> `inst.idl`_`inst.role`_api_tobj;
static ManuallyConstructed<MsgQueMessageBufferFactory> `inst.idl`_`inst.role`_api_mbfobj;
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_api_bcfobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_api_crcobj;
static ManuallyConstructed<ClientManager> `inst.idl`_`inst.role`_api_cmobj;
% }
% if (sluart_used) {
/* TODO - UartSimpleLinkTransport object */
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_api_bcfobj;
static ManuallyConstructed<BasicCodec> `inst.idl`_`inst.role`_api_bcobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_api_crcobj;
static ManuallyConstructed<TransportArbitrator> `inst.idl`_`inst.role`_taobj;
static ManuallyConstructed<ArbitratedClientManager> `inst.idl`_`inst.role`_api_acmobj;
% }
%
% if (inst.hasCbk) {

/* IDL: `inst.idl`, callback server objects */
% if (msgque_used) {
static ManuallyConstructed<MsgQueTransport> `inst.idl`_`inst.role`_cbk_tobj;
static ManuallyConstructed<MsgQueMessageBufferFactory> `inst.idl`_`inst.role`_cbk_mbfobj;
% }
% if (sluart_used) {
/* TODO - UartSimpleLinkTransport object */
% }
static ManuallyConstructed<SimpleServer> `inst.idl`_`inst.role`_cbk_ssobj;
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_cbk_bcfobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_cbk_crcobj;
% }

/* IDL: `inst.idl`, client manager interface declarations */
% // Interfaces without groups will share the same source file. Track the
% // client manager interface declarations in order to eliminate duplicates.
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
extern ClientManager *`name`;
% used += name + "/";
% }
% }
% } else { /* "server" */

/* IDL: `inst.idl`, server objects */
% if (msgque_used) {
static ManuallyConstructed<MsgQueTransport> `inst.idl`_`inst.role`_api_tobj;
static ManuallyConstructed<MsgQueMessageBufferFactory> `inst.idl`_`inst.role`_api_mbfobj;
% }
% if (sluart_used) {
/* TODO - UartSimpleLinkTransport object */
% }
static ManuallyConstructed<SimpleServer> `inst.idl`_`inst.role`_api_ssobj;
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_api_bcfobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_api_crcobj;
%
% if (inst.hasCbk) {

/* IDL: `inst.idl`, callback client manager objects */
% if (msgque_used) {
static ManuallyConstructed<MsgQueTransport> `inst.idl`_`inst.role`_cbk_tobj;
static ManuallyConstructed<MsgQueMessageBufferFactory> `inst.idl`_`inst.role`_cbk_mbfobj;
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_cbk_bcfobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_cbk_crcobj;
static ManuallyConstructed<ClientManager> `inst.idl`_`inst.role`_cbk_cmobj;
% }
% if (sluart_used) {
/* TODO - UartSimpleLinkTransport object */
% if (inst.hasCbk) {
static ManuallyConstructed<BasicCodecFactory> `inst.idl`_`inst.role`_cbk_bcfobj;
static ManuallyConstructed<BasicCodec> `inst.idl`_`inst.role`_cbk_bcobj;
static ManuallyConstructed<Crc16> `inst.idl`_`inst.role`_cbk_crcobj;
static ManuallyConstructed<TransportArbitrator> `inst.idl`_`inst.role`_taobj;
static ManuallyConstructed<ArbitratedClientManager> `inst.idl`_`inst.role`_cbk_acmobj;
% }
% }

/* IDL: `inst.idl`, callback client manager interface declarations */
% // track client manager declarations in order to eliminate duplicates
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (inst.hasCbk && ifs[j].isCbk) {
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
extern ClientManager *`name`;
% used += name + "/";
% }
% }
% }
% }
% }
% } /* foreach instance */

#if defined (__cplusplus)
extern "C" {
#endif
%
% let fxns = new Array();
% for (let i = 0; i < ERPC.$instances.length; i++) {
% let inst = ERPC.$instances[i];
% let ifs = findInterfaces(inst);
% let setupFxn = [inst.idl, inst.role, "setup"].join("_");
% fxns.push(setupFxn);

static void `setupFxn`(void)
{
    erpc_transport_t transport;
    erpc_mbf_t msg_buf_fact;
% if (msgque_used) {
% if (inst.role == "client") {
    MsgQue_Handle api_sendq, api_rplyq;
% if (inst.hasCbk) {
    MsgQue_Handle cbk_retnq, cbk_recvq;
% }
% } else {
    MsgQue_Handle api_retnq, api_recvq;
% if (inst.hasCbk) {
    MsgQue_Handle cbk_sendq, cbk_rplyq;
% }
% }
% } /* msgque_used */
% if (sluart_used) {
    /* TODO - UartSimpleLinkTransport object */
% if (inst.hasCbk) {
    erpc_transport_t arbitrator;
% }
% }

% if (inst.role == "client") {
% if (msgque_used) {
    /* create client manager and transport objects */
    MsgQue_construct(&api_sendq, CONFIG_MsgQue_`inst.idl`_`inst.role`_api_sendq);
    MsgQue_construct(&api_rplyq, CONFIG_MsgQue_`inst.idl`_`inst.role`_api_rplyq);

    transport = erpc_transport_msgque_init_ref(api_sendq, api_rplyq, &`inst.idl`_`inst.role`_api_tobj);
    msg_buf_fact = erpc_mbf_msgque_init_ref(api_sendq, api_rplyq, &`inst.idl`_`inst.role`_api_mbfobj);
    erpc_client_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_cmobj, &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_crcobj);

    /* bind interfaces to client manager */
% // track client manager declarations in order to eliminate duplicates
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
    `name` = `inst.idl`_`inst.role`_api_cmobj;
% used += name + "/";
% }
% }
%
% if (inst.hasCbk) {

    /* create callback server and transport obects */
    MsgQue_construct(&cbk_retnq, CONFIG_MsgQue_`inst.idl`_`inst.role`_cbk_retnq);
    MsgQue_construct(&cbk_recvq, CONFIG_MsgQue_`inst.idl`_`inst.role`_cbk_recvq);

    transport = erpc_transport_msgque_init_ref(cbk_retnq, cbk_recvq, &`inst.idl`_`inst.role`_cbk_tobj);
    msg_buf_fact = erpc_mbf_msgque_init_ref(cbk_retnq, cbk_recvq, &`inst.idl`_`inst.role`_cbk_mbfobj);
    erpc_server_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_cbk_ssobj, &`inst.idl`_`inst.role`_cbk_bcfobj, &`inst.idl`_`inst.role`_cbk_crcobj);

    /* add services to rpc server */
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) {
    erpc_add_service_to_server_ref(create_`ifs[j].ifn`_service(), &`inst.idl`_`inst.role`_cbk_ssobj);
% }
% }
% }
% } /* msgque_used */
%
% if (sluart_used) {
% if (inst.hasCbk) {
    /* create shared transport, arbitrator, and server objects */
    transport = erpc_transport_uart_simplelink_init(`inst.uart.$name`, 115200);
    msg_buf_fact = erpc_mbf_static_init();
    arbitrator = erpc_arbitrated_client_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_acmobj, &`inst.idl`_`inst.role`_taobj,
            &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_bcobj, &`inst.idl`_`inst.role`_api_crcobj);
    erpc_server_init_ref(arbitrator, msg_buf_fact,
            &`inst.idl`_`inst.role`_cbk_ssobj, &`inst.idl`_`inst.role`_cbk_bcfobj, &`inst.idl`_`inst.role`_cbk_crcobj);
% } else {
    /* create client manager and transport objects */
    transport = erpc_transport_uart_simplelink_init(`inst.uart.$name`, 115200);
    msg_buf_fact = erpc_mbf_static_init();
    erpc_client_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_cmobj, &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_crcobj);
% }

    /* bind interfaces to client manager */
% // track client manager declarations in order to eliminate duplicates
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
% if (inst.hasCbk) {
    `name` = `inst.idl`_`inst.role`_api_acmobj;
% } else {
    `name` = `inst.idl`_`inst.role`_api_cmobj;
% }
% used += name + "/";
% }
% }
%
% if (inst.hasCbk) {

    /* add services to rpc server */
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) {
    erpc_add_service_to_server_ref(create_`ifs[j].ifn`_service(), &`inst.idl`_`inst.role`_cbk_ssobj);
% }
% }
% }
% } /* sluart_used */
% } /* role: client */
%
% else { // role: server
% if (msgque_used) {
    /* create api transport and server objects */
    MsgQue_open(&api_retnq, CONFIG_MsgQue_`inst.idl`_`inst.role`_api_retnq);
    MsgQue_open(&api_recvq, CONFIG_MsgQue_`inst.idl`_`inst.role`_api_recvq);

    transport = erpc_transport_msgque_init_ref(api_retnq, api_recvq, &`inst.idl`_`inst.role`_api_tobj);
    msg_buf_fact = erpc_mbf_msgque_init_ref(api_retnq, api_recvq, &`inst.idl`_`inst.role`_api_mbfobj);
    erpc_server_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_ssobj, &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_crcobj);

    /* add api services to rpc server */
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
    erpc_add_service_to_server_ref(create_`ifs[j].ifn`_service(), &`inst.idl`_`inst.role`_api_ssobj);
% }
%
% if (inst.hasCbk) {

    /* create callback client manager and transport objects */
    MsgQue_open(&cbk_sendq, CONFIG_MsgQue_`inst.idl`_`inst.role`_cbk_sendq);
    MsgQue_open(&cbk_rplyq, CONFIG_MsgQue_`inst.idl`_`inst.role`_cbk_rplyq);

    transport = erpc_transport_msgque_init_ref(cbk_sendq, cbk_rplyq, &`inst.idl`_`inst.role`_cbk_tobj);
    msg_buf_fact = erpc_mbf_msgque_init_ref(cbk_sendq, cbk_rplyq, &`inst.idl`_`inst.role`_cbk_mbfobj);
    erpc_client_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_cbk_cmobj, &`inst.idl`_`inst.role`_cbk_bcfobj, &`inst.idl`_`inst.role`_cbk_crcobj);

    /* bind callback interfaces to client manager */
% // track client manager declarations in order to eliminate duplicates
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) {
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
    `name` = `inst.idl`_`inst.role`_cbk_cmobj;
% used += name + "/";
% }
% }
% } /* foreach interface */
% } /* inst.hasCbk */
% } /* msgque_used */
%
% if (sluart_used) {
% if (inst.hasCbk) {
    /* create shared transport, arbitrator, and server objects */
    transport = erpc_transport_uart_simplelink_init(`inst.uart.$name`, 115200);
    msg_buf_fact = erpc_mbf_static_init();
    arbitrator = erpc_arbitrated_client_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_cbk_acmobj, &`inst.idl`_`inst.role`_taobj,
            &`inst.idl`_`inst.role`_cbk_bcfobj, &`inst.idl`_`inst.role`_cbk_bcobj, &`inst.idl`_`inst.role`_cbk_crcobj);
    erpc_server_init_ref(arbitrator, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_ssobj, &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_crcobj);
% } else {
    /* create api transport and server objects */
    transport = erpc_transport_uart_simplelink_init(`inst.uart.$name`, 115200);
    msg_buf_fact = erpc_mbf_static_init();
    erpc_server_init_ref(transport, msg_buf_fact,
            &`inst.idl`_`inst.role`_api_ssobj, &`inst.idl`_`inst.role`_api_bcfobj, &`inst.idl`_`inst.role`_api_crcobj);
% }

    /* add api services to rpc server */
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) continue;
    erpc_add_service_to_server_ref(create_`ifs[j].ifn`_service(), &`inst.idl`_`inst.role`_api_ssobj);
% }
% if (inst.hasCbk) {

    /* bind callback interfaces to client manager */
% // track client manager declarations in order to eliminate duplicates
% let used = "/"
% for (let j = 0; j < ifs.length; j++) {
% if (ifs[j].isCbk) {
% let tag = (ifs[j].tag != "" ? "_" + ifs[j].tag : "");
% let name = inst.idl + tag + "_cm";
% if (used.indexOf(name) == -1) {
    `name` = `inst.idl`_`inst.role`_cbk_acmobj;
% used += name + "/";
% }
% }
% } /* foreach interface */
% }
% } /* sluart_used */
% } /* role: server */
}
% let runFxn = ["ti_rpc_erpc", inst.idl, inst.role, "run"].join("_");
% if ((inst.role == "client") && (inst.hasCbk)) {

/*
 *  ======== `runFxn` ========
 */
void `runFxn`(void)
{
    /* run the server, does not return */
    erpc_server_run_ref(&`inst.idl`_`inst.role`_cbk_ssobj);
}
% }
% if (inst.role == "server") {

/*
 *  ======== `runFxn` ========
 */
void `runFxn`(void)
{
    /* run the server, does not return */
    erpc_server_run_ref(&`inst.idl`_`inst.role`_api_ssobj);
}
% }
% } /* foreach instance */

/*
 *  ======== ti_rpc_erpc_setup ========
 */
void ti_rpc_erpc_setup(void)
{
% for (let i = 0; i < fxns.length; i++) {
    `fxns[i]`();
% }
}

#if defined (__cplusplus)
}
#endif
